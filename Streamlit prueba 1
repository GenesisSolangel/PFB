import streamlit as st
import pandas as pd
import requests
from datetime import datetime, timedelta
import time
import plotly.express as px

# Configuraci√≥n de la p√°gina
st.set_page_config(page_title="Red El√©ctrica", layout="centered")

# API REE
BASE_URL = "https://apidatos.ree.es/es/datos/"
HEADERS = {"accept": "application/json", "content-type": "application/json"}
ENDPOINTS = {
    "demanda": ("demanda/evolucion", "hour"),
    "balance": ("balance/balance-electrico", "day"),
    "generacion": ("generacion/potencia-instalada", "month"),
    "intercambios": ("intercambios/todas-fronteras-programados", "day")
}

# Funci√≥n para consultar un endpoint
def get_data(endpoint_name, path, granularity, start_date, end_date):
    params = {
        "start_date": start_date.strftime("%Y-%m-%dT%H:%M"),
        "end_date": end_date.strftime("%Y-%m-%dT%H:%M"),
        "geo_trunc": "electric_system",
        "geo_limit": "peninsular",
        "geo_ids": "8741",
        "time_trunc": granularity
    }
    url = BASE_URL + path

    try:
        response = requests.get(url, headers=HEADERS, params=params)
        if response.status_code != 200:
            return []
        response_data = response.json()
    except:
        return []

    data = []
    for item in response_data.get("included", []):
        attrs = item.get("attributes", {})
        category = attrs.get("title")

        if "content" in attrs:
            for sub in attrs["content"]:
                sub_attrs = sub.get("attributes", {})
                sub_cat = sub_attrs.get("title")
                for entry in sub_attrs.get("values", []):
                    entry["primary_category"] = category
                    entry["sub_category"] = sub_cat
                    data.append(entry)
        else:
            for entry in attrs.get("values", []):
                entry["primary_category"] = category
                entry["sub_category"] = None
                data.append(entry)

    return data

# Funci√≥n principal
def main():
    st.title("An√°lisis de la Red El√©ctrica Espa√±ola")

    # Pesta√±as
    tab1, tab2, tab3 = st.tabs(["Descripci√≥n", "Consulta de datos", "üìä Visualizaci√≥n"])

    # TAB 1: Descripci√≥n
    with tab1:
        st.subheader("¬øQu√© es esta app?")
        st.markdown("""
        Esta aplicaci√≥n web interactiva se conecta con la API oficial de Red El√©ctrica de Espa√±a (REE) para ofrecer una visualizaci√≥n clara y actualizada del estado del sistema el√©ctrico nacional. A trav√©s de un entorno intuitivo, permite explorar datos relacionados con el balance energ√©tico, la demanda, la generaci√≥n y los intercambios de electricidad, tanto en tiempo real como en per√≠odos hist√≥ricos.
        
        Los usuarios pueden consultar informaci√≥n detallada filtrando por d√≠as recientes (7, 14 o 30 d√≠as) o comparando diferentes a√±os, facilitando as√≠ el an√°lisis de tendencias y comportamientos del sistema el√©ctrico. Adem√°s, la aplicaci√≥n incluye un modelo de predicci√≥n de la demanda el√©ctrica, desarrollado con t√©cnicas de an√°lisis de datos, cuyos resultados tambi√©n se muestran de forma visual e interpretativa.
        """)

    # TAB 2: Consulta
    with tab2:
        st.subheader("Consulta de datos")

        tipo = st.radio("Selecciona el tipo de consulta:", ["A√±os", "√öltimos d√≠as"], horizontal=True)

        if tipo == "A√±os":
            a√±os = st.selectbox("¬øCu√°ntos a√±os quieres consultar?", [1, 2, 3])
            start_date = datetime(datetime.now().year - a√±os, 1, 1)
        else:
            dias = st.selectbox("¬øCu√°ntos d√≠as atr√°s?", [7, 14, 30])
            start_date = datetime.now() - timedelta(days=dias)

        end_date = datetime.now()

        if st.button("üîç Obtener datos"):
            all_dfs = []

            for name, (path, granularity) in ENDPOINTS.items():
                datos = get_data(name, path, granularity, start_date, end_date)

                if datos:
                    df = pd.DataFrame(datos)

                    if 'datetime' in df.columns:
                        df['datetime'] = pd.to_datetime(df['datetime'], errors='coerce')
                        df.dropna(subset=['datetime'], inplace=True)

                        if pd.api.types.is_datetime64_any_dtype(df['datetime']) and not df.empty:
                            df['year'] = df['datetime'].dt.year
                            df['month'] = df['datetime'].dt.month
                            df['day'] = df['datetime'].dt.day
                            df['hour'] = df['datetime'].dt.strftime('%H:%M:%S')
                            df['endpoint'] = name

                            df = df[['value', 'percentage', 'datetime', 'primary_category',
                                     'sub_category', 'year', 'month', 'day', 'hour', 'endpoint']]
                            all_dfs.append(df)
                        else:
                            st.warning(f"Los datos para '{name}' no tienen fechas v√°lidas.")
                    else:
                        st.warning(f"Los datos para '{name}' no incluyen columna 'datetime'.")

                time.sleep(0.2)

            if all_dfs:
                final_df = pd.concat(all_dfs, ignore_index=True)
                st.session_state["ree_data"] = final_df
                st.success("‚úÖ Datos cargados correctamente.")
            else:
                st.warning("No se encontraron datos v√°lidos en este per√≠odo.")

    # TAB 3: Visualizaci√≥n
    with tab3:
        st.subheader("Visualizaci√≥n de datos")

        if "ree_data" in st.session_state:
            df = st.session_state["ree_data"]

            endpoint = st.selectbox("Selecciona el tipo de dato", df["endpoint"].unique())
            df_filtrado = df[df["endpoint"] == endpoint]

            fig = px.line(df_filtrado,
                          x="datetime",
                          y="value",
                          color="primary_category",
                          title=f"Evoluci√≥n: {endpoint}",
                          labels={"value": "Valor", "datetime": "Fecha"})
            st.plotly_chart(fig, use_container_width=True)

            with st.expander("Ver datos en tabla"):
                st.dataframe(df_filtrado, use_container_width=True)
        else:
            st.info("Primero consulta los datos en la pesta√±a anterior.")

# Ejecutar la app
if __name__ == "__main__":
    main()
